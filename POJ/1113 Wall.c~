#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#define N 1005
#define PI 3.141592653
#define CROSS(x1, y1, x2, y2) (((x1) * (y2)) - ((x2) * (y1)))
#define DIS(x, y) ((x) * (x) + (y) * (y))
#define DISTANCE(x, y) sqrt((double)(DIS(x, y)))

struct point
{
	int x, y;
};

struct point point[N], res[N];
int minX, minY;

int cmp(const void *a, const void *b)
{
	struct point *aa = (struct point *)a;
	struct point *bb = (struct point *)b;
	int cross;

	cross = CROSS(aa->x - minX, aa->y - minY, bb->x - minX, bb->y - minY);

	if (cross > 0)
		return -1;
	else
		if (cross < 0)
			return 1;
		else
			return (DIS((aa->x - minX), (aa->y - minY))) - (DIS((bb->x - minX), (bb->y - minY)));
}

int Graham(struct point *pts, int n)
{
	int i, j;
	int cross;

	res[0] = point[0];
	res[1] = point[1];
	for(i  = 2, j = 1;i < n;i++)
	{
		cross = CROSS(point[i].x - res[j].x, point[i].y - res[j].y, res[j].x - res[j - 1].x, res[j].y - res[j - 1].y);
		while(j >= 1 && cross >= 0)
		{
			j--;
			cross = CROSS(point[i].x - res[j].x, point[i].y - res[j].y, res[j].x - res[j - 1].x, res[j].y - res[j - 1].y);
		}
		res[++j].x = point[i].x;
		res[j].y = point[i].y;
	}
	return j + 1;
}

int main()
{
	int i, j, l, n, minId, pointNum;
	double len;
	struct point temp;

	scanf("%d %d", &n, &l);
	for(i = 0;i < n;i++)
		scanf("%d %d", &point[i].x, &point[i].y);

	minX = point[0].x;
	minY = point[0].y;
	minId = 0;

	for(i = 1;i < n;i++)
		if (point[i].y < minY || (point[i].y == minY && point[i].x < minX))
		{
			minX = point[i].x;
			minY = point[i].y;
			minId = i;
		}
	temp = point[minId];
	point[minId] = point[0];
	point[0] = temp;

	qsort(point + 1, n - 1, sizeof(point[0]), cmp);

	pointNum= Graham(point, n);

	len = DISTANCE((double)(res[0].x - res[pointNum - 1].x), (double)(res[0].y - res[pointNum - 1].y));

	for(i = 1; i < pointNum;i++)
		len += DISTANCE((double)(res[i].x - res[i - 1].x), (double)(res[i].y - res[i- 1].y));

	printf("%d\n", (int)(len +  2 * PI * l + 0.5));
	return 0;
}
