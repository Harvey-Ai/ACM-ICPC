#include <iostream>
#include <map>
#include <cstring>
#include <queue>
using namespace std;

struct point
{
	int x, y;

	point()
	{
		x = y = 0;
	}
	point(int xx, int yy)
	{
		x = xx;
		y = yy;
	}
};

int minDist[15][15];
int dp[1 << 12][12];
int dirtyNum;

void dfs(int status, int cur, int val)
{
	if (dp[status][cur] != -1 && dp[status][cur] < val)
		return;

	dp[status][cur] = val;
	for(int i = 0;i < dirtyNum;i++)
	{
		if (status & (1 << i))
			continue;

        if (minDist[cur][i] > 0)
            dfs(status | (1 << i), i, val + minDist[cur][i]);
	}
}


int main()
{
	char titleMap[21][21];
	point dirtyPoint[20];
	int h, w;
	int startIndex;
	
	while(cin >> w >> h, h || w)
	{
		dirtyNum = 0;
		for(int i = 0;i < h;i++)
		{
			cin >> titleMap[i];
			for(int j = 0;j < w;j++)
				if (titleMap[i][j] == '*' || titleMap[i][j] == 'o')
				{
					dirtyPoint[dirtyNum].x = i;
					dirtyPoint[dirtyNum].y = j;
					if (titleMap[i][j] == 'o')
						startIndex = dirtyNum;
					dirtyNum++;
				}
		}
		for(int i = 0;i < dirtyNum;i++)
			for(int j = 0;j < dirtyNum;j++)
				minDist[i][j] = -1;

		for(int i = 0;i < dirtyNum;i++)
		{
			queue<pair<point, int> > pointQ;
			pointQ.push(make_pair(dirtyPoint[i], 0));

			int visited[25][25];
			memset(visited, 0, sizeof(visited));
			visited[dirtyPoint[i].x][dirtyPoint[i].y] = 1;

			while(!pointQ.empty())
			{
				point currentPoint = pointQ.front().first;
				int dist = pointQ.front().second;
				int currentX = currentPoint.x, currentY = currentPoint.y;
				pointQ.pop();

				if (currentX - 1 >= 0 && titleMap[currentX - 1][currentY] != 'x' && !visited[currentX - 1][currentY])
				{
					pointQ.push(make_pair(point(currentX - 1, currentY), dist + 1));
					visited[currentX - 1][currentY] = 1;
				}
				if (currentX + 1 < h && titleMap[currentX + 1][currentY] != 'x' && !visited[currentX + 1][currentY])
				{
					pointQ.push(make_pair(point(currentX + 1, currentY), dist + 1));
					visited[currentX + 1][currentY] = 1;
				}
				if (currentY - 1 >= 0 && titleMap[currentX][currentY - 1] != 'x' && !visited[currentX][currentY - 1])
				{
					pointQ.push(make_pair(point(currentX, currentY - 1), dist + 1));
					visited[currentX][currentY - 1] = 1;
				}
				if (currentY + 1 < w && titleMap[currentX][currentY + 1] != 'x' && !visited[currentX][currentY + 1])
				{
					pointQ.push(make_pair(point(currentX, currentY + 1), dist + 1));
					visited[currentX][currentY + 1] = 1;
				}

				for(int j = 0;j < dirtyNum;j++)
				{
					if (j == i)	continue;
					if (dirtyPoint[j].x == currentPoint.x && dirtyPoint[j].y == currentPoint.y)
						minDist[i][j] = dist;
				}
			}
		}

		for(int i = 0;i < (1 << dirtyNum);i++)
			for(int j = 0;j < dirtyNum;j++)
				dp[i][j] = -1;
		dfs(1 << (startIndex), startIndex, 0);

		int res = -1;
		int fullStatus = (1 << dirtyNum) - 1;
		for(int i = 0;i < dirtyNum;i++)
		{
            if (dp[fullStatus][i] == -1)
                continue;
			if (res == -1 || res > dp[fullStatus][i])
				res = dp[fullStatus][i];
		}

		cout << res << endl;
	}
	return 0;
}
