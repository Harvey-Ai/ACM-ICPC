/*
题目描述：
在BaiDu搜索引擎里,如何提高搜索效率是研发人员为之奋斗的目标。现在,JOBDU密码库里也有一段数字片段S(0<长度<=100,000),HQ想通过智能搜索得到包含关键字P(0<长度<=100,000)的某个数段长度,如果存在多个这样的数段,则选择长度最小的。例如,数字片段123456789,关键字为257.显然S本身就包含257,所以长度9是一个符合的数段,但是HQ从S中找到子串234567也包含关键字,并且无法找到更短的子串满足条件,因此返回结果6。PS：JOBDU密码库里的数字片段可能包含“*”,表示这一位可以是(0~9)中任意1个,具体见案例2。
输入：
输入有多个测试案例,每个测试案例1行,包括两个字串。
第一个为数字片段S(0<长度<=100,000),第二个为关键字P(0<长度<=100,000)。
输出：
根据输入案例返回查找结果,如果不存在包含关键字的数字片段则返回0。
样例输入：
123456789 257
33**2*** 113

样例输出：
6
3

提示：
测试案例2中,可以把S中前两个“**”看成“11”或者最后三个“***”看成“113” (“131”|”311”均可),那么“3**”和“***”都是符合的结果,且长度为3。
*/


#include <iostream>
using namespace std;

char templ[100005], str[100005];
int main()
{
	while(scanf("%s", templ) != EOF)
	{
		scanf("%s", str);
		if (strlen(templ) < strlen(str))
			cout << 0 << endl;

		stateNum = 0;
		for(i = 0;templ[i] != '\0';i++)
		{
			

		}
		
	return 0;
}
